<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="js-widget-title" content="Nearby Stops + Realtime" />
  <title>Nearby Stops + Realtime</title>

  <!-- Leaflet (local) -->
  <link rel="stylesheet" href="./leaflet.css">
  <script src="./leaflet.js"></script>

  <style>
    :root{
      --bg: #0f1012;
      --panel: rgba(20,20,22,.62);
      --panel2: rgba(255,255,255,.10);
      --border: rgba(255,255,255,.14);
      --text: #fff;
      --muted: rgba(255,255,255,.82);
      --err: #ffb3b3;
    }

    html, body {
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      font-family: -apple-system, system-ui, Arial;
      background: var(--bg);
      overflow: hidden;
    }

    /* Whole app is sized for widget */
    #app {
      height: 100vh;
      width: 100vw;
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: 0;
    }

    /* top bar: only refresh + time */
    .topbar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 1vh;
      padding: 1vh 1vw;
      color: var(--text);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap: 0.8vh;
      padding: 0.6vh 1vw;
      border-radius: 999px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 1vh 2.5vh rgba(0,0,0,.22);
      font-weight: 800;
      font-size: 1.5vh;
      white-space: nowrap;
    }

    .time{
      font-variant-numeric: tabular-nums;
      opacity: .95;
    }

    .iconbtn{
      width: 4vh;
      height: 4vh;
      border: 0;
      border-radius: 1.2vh;
      cursor: pointer;
      display: grid;
      place-items: center;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      color: #fff;
      -webkit-tap-highlight-color: transparent;
    }
    .iconbtn:active { transform: translateY(1px); }
    .iconbtn:disabled { opacity: .45; cursor: default; }

    .icon { width: 2vh; height: 2vh; display: block; }
    .spin { animation: spin 0.9s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* MAIN: side-by-side always (XL widget style) */
    .main{
      position: relative;
      display:grid;
      grid-template-columns: 44% 56%; /* stops | map */
      gap: 1vh;
      padding: 0 1vw 1vh 1vw;
      min-height: 0;
      height: 100%;
      overflow: hidden;
    }

    /* left panel */
    .panel{
      min-height: 0;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 1.6vh;
      box-shadow: 0 1vh 2.5vh rgba(0,0,0,.22);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    .panel-head{
      padding: 1vh 1.2vw;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 1vh;
      border-bottom: 1px solid rgba(255,255,255,.10);
      flex: 0 0 auto;
    }

    .panel-title{
      font-weight: 900;
      font-size: 1.6vh;
      color: var(--text);
      opacity: .98;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .panel-sub{
      font-size: 1.4vh;
      color: var(--muted);
      opacity: .9;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    /* IMPORTANT: no internal scroll for widget -> show only what fits */
    .cards{
      padding: 1vh;
      display:grid;
      gap: 1vh;
      overflow: hidden;
      flex: 1 1 auto;
      min-height: 0;
    }

    .card{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 1.4vh;
      padding: 1vh;
    }

    .card-top{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 1vh;
      color: var(--text);
    }

    .stop-name{
      font-weight: 900;
      font-size: 1.6vh;
      line-height: 1.2;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 74%;
    }

    .dist{
      font-size: 1.4vh;
      opacity: .85;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .arrivals{
      margin-top: 0.8vh;
      display:grid;
      gap: 0.6vh;
      color: var(--muted);
      font-size: 1.5vh;
      min-height: 0;
    }

    .arrival-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 1vh;
      padding: 0.6vh 0.8vw;
      border-radius: 1vh;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      font-variant-numeric: tabular-nums;
    }

    .line{
      font-weight: 900;
      color: #fff;
      opacity: .95;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 68%;
    }

    .eta{
      white-space: nowrap;
      color: #fff;
      opacity: .95;
      font-weight: 900;
    }

    .mins{
      opacity: .9;
      font-weight: 800;
    }

    /* map */
    .mapWrap{
      min-height: 0;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 1.6vh;
      overflow:hidden;
      box-shadow: 0 1vh 2.5vh rgba(0,0,0,.22);
      position: relative;
    }

    #map{
      position:absolute;
      inset:0;
    }

    /* Make Leaflet controls a bit smaller */
    .leaflet-control-zoom a{
      width: 3vh !important;
      height: 3vh !important;
      line-height: 3vh !important;
    }

    /* Keep attribution tiny */
    .leaflet-control-attribution{
      font-size: 1vh !important;
      opacity: .55;
      background: rgba(255,255,255,.65) !important;
      border-radius: 1vh !important;
      padding: 0.2vh 0.6vw !important;
      margin: 0 0.8vw 0.8vh 0 !important;
    }

    /* markers */
    .stopBadge{
      width: 2.4vh;
      height: 2.4vh;
      border-radius: 999px;
      display:grid;
      place-items:center;
      font-weight: 900;
      font-size: 1.3vh;
      color: #fff;
      background: rgba(255,255,255,.18);
      border: 2px solid rgba(255,255,255,.70);
      box-shadow: 0 0.8vh 1.8vh rgba(0,0,0,.25);
    }

    /* loading cover */
    .loading{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      z-index: 999999;
      background: linear-gradient(180deg, rgba(15,16,18,.96), rgba(15,16,18,.84));
      color: #fff;
      font-weight: 900;
      text-align:center;
      padding: 2vh;
    }
    .loading small{
      display:block;
      margin-top: 0.8vh;
      font-weight: 700;
      opacity: .75;
    }
    .errText{
      color: var(--err);
      font-weight: 900;
      margin-top: 1vh;
      font-size: 1.5vh;
      white-space: pre-wrap;
      text-align: right;
      max-width: 56vw;
    }

    /* Widget XL tightening: shrink on very small heights but keep side-by-side */
    @media (max-height: 420px) and (max-width: 800px){
      .topbar{ padding: 0.8vh 1vw; }
      .main{ gap: 0.8vh; padding: 0 1vw 1vh 1vw; }
      .panel-head{ padding: 0.8vh 1vw; }
      .cards{ padding: 0.8vh; gap: 0.8vh; }
      .card{ padding: 0.9vh; }
      .stop-name{ font-size: 1.5vh; }
      .arrivals{ margin-top: 0.7vh; gap: 0.6vh; }
      .arrival-row{ padding: 0.5vh 0.7vw; }
      
      /* Adjust grid for very small screens but keep side-by-side */
      .main {
        grid-template-columns: 48% 52%;
      }
    }
    
    /* For extremely narrow width, switch to vertical layout */
    @media (max-width: 500px) {
      .main {
        grid-template-columns: 100%;
        grid-template-rows: 50% 50%;
        gap: 1vh;
      }
      .panel {
        height: 100%;
      }
      .mapWrap {
        height: 100%;
      }
    }

    /* Ensure everything fits within viewport */
    * {
      box-sizing: border-box;
      max-width: 100vw;
      max-height: 100vh;
    }
  </style>
</head>

<body>
<div id="app">
  <div class="topbar">
    <div class="pill">
      <span>עודכן</span>
      <span class="time" id="updatedTime">—</span>
    </div>

    <button class="iconbtn" id="refreshBtn" title="רענן">
      <svg class="icon" id="refreshIcon" viewBox="0 0 24 24" fill="none">
        <path d="M20 12a8 8 0 1 1-2.34-5.66" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <path d="M20 4v6h-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>

  <div class="main" id="mainRoot">
    <div class="panel">
      <div class="panel-head">
        <div>
          <div class="panel-title">2 התחנות הקרובות</div>
          <div class="panel-sub" id="statusLine">טוען…</div>
        </div>
      </div>
      <div class="cards" id="cards"></div>
    </div>

    <div class="mapWrap">
      <div id="map"></div>
      <div class="loading" id="loadingCover">
        טוען נתונים…
        <small>מיקום → תחנות קרובות → זמני הגעה</small>
        <div class="errText" id="errBox" style="display:none;"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  if (typeof __wweb2Log === 'undefined') window.__wweb2Log = (str) => console.log(str);

  // ========= CONFIG =========
  const NEARBY_BASE = "https://script.google.com/macros/s/AKfycbwP9zZV4XDe8tsAdGAr3w3E8paS0-eQagw9b7gTnJBwYvqVbqZsbuFEN7FFPD7t-WeL/exec";
  const REALTIME_BASE = "https://kavnav.com/api/realtime";
  const PROXY_BASE = "https://script.google.com/macros/s/AKfycbxKfWtTeeoOJCoR_WD4JQhvDGHcE3j82tVHVQXqElwL9NVO9ourZxSHTA20GoBJKfmiLw/exec";

  const FALLBACK_CENTER = [31.78, 35.22];
  const FALLBACK_ZOOM = 17;   // more focused for widget
  const USER_ZOOM = 17;

  // Widget-friendly: show only 2 arrivals per stop (no scroll)
  const MAX_ARRIVALS_PER_STOP = 2;

  // ========= DOM =========
  const el = (id) => document.getElementById(id);
  const updatedTimeEl = el("updatedTime");
  const refreshBtn = el("refreshBtn");
  const refreshIcon = el("refreshIcon");
  const statusLine = el("statusLine");
  const cardsEl = el("cards");
  const loadingCover = el("loadingCover");
  const errBox = el("errBox");

  // ========= STATE =========
  let map = null;
  let userMarker = null;
  let stopMarkers = [];
  let lastRendered = false;

  // ========= HELPERS =========
  function proxyUrl(url) {
    return `${PROXY_BASE}?url=${encodeURIComponent(url)}`;
  }

  function fmtTimeOnly(d) {
    const date = (d instanceof Date) ? d : new Date(d);
    if (!isFinite(date.getTime())) return "—";
    return date.toLocaleTimeString("he-IL", { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  }

  function fmtDist(m) {
    if (!isFinite(m)) return "—";
    if (m < 1000) return `${Math.round(m)} מ׳`;
    return `${(m/1000).toFixed(1)} ק״מ`;
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function showError(msg) {
    errBox.style.display = "block";
    errBox.textContent = msg;
  }

  function hideError() {
    errBox.style.display = "none";
    errBox.textContent = "";
  }

  // ========= GEOLOCATION =========
  async function getMyLocation() {
    return new Promise((resolve) => {
      if (!navigator.geolocation) {
        resolve({ lat: FALLBACK_CENTER[0], lon: FALLBACK_CENTER[1], isFallback: true });
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude, isFallback: false }),
        () => resolve({ lat: FALLBACK_CENTER[0], lon: FALLBACK_CENTER[1], isFallback: true }),
        { enableHighAccuracy: false, timeout: 1500, maximumAge: 60_000 }
      );
    });
  }

  // ========= NETWORK =========
  async function fetchJson(url, useProxy = false) {
    const finalUrl = useProxy ? proxyUrl(url) : url;
    const res = await fetch(finalUrl, { cache: "no-store" });
    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      throw new Error(`HTTP ${res.status}\n${txt.slice(0,160)}`);
    }
    const text = await res.text();
    try { return JSON.parse(text); }
    catch { throw new Error("Invalid JSON response"); }
  }

  async function fetchNearbyStops(lat, lon) {
    const url = `${NEARBY_BASE}?fn=nearbyStops&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&limit=2`;
    return fetchJson(url, false);
  }

  async function fetchRealtimeForStop(stopCode) {
    const url = `${REALTIME_BASE}?stopCode=${encodeURIComponent(stopCode)}`;
    return fetchJson(url, true);
  }

  // ========= REALTIME PARSING =========
  function extractArrivalsForStop(realtimeJson, stopCode, maxRows) {
    const vehicles = Array.isArray(realtimeJson?.vehicles) ? realtimeJson.vehicles : [];
    const rows = [];
    for (const v of vehicles) {
      const calls = v?.trip?.onwardCalls?.calls;
      if (!Array.isArray(calls)) continue;

      const match = calls.find(c => String(c?.stopCode) === String(stopCode) && c?.eta);
      if (!match) continue;

      const etaDate = new Date(match.eta);
      if (!isFinite(etaDate.getTime())) continue;

      rows.push({
        routeNumber: String(v?.trip?.gtfsInfo?.routeNumber ?? "—"),
        headsign: String(v?.trip?.gtfsInfo?.headsign ?? ""),
        etaDate
      });
    }
    rows.sort((a, b) => a.etaDate - b.etaDate);
    return rows.slice(0, maxRows);
  }

  function computeUpdatedTimeFromRealtime(rtA, rtB) {
    const candidates = [
      rtA?.lastSnapshot, rtA?.lastVehicleReport,
      rtB?.lastSnapshot, rtB?.lastVehicleReport
    ].filter(Boolean);

    let best = null;
    for (const c of candidates) {
      const d = new Date(c);
      if (!isFinite(d.getTime())) continue;
      if (!best || d > best) best = d;
    }
    return best ? fmtTimeOnly(best) : fmtTimeOnly(new Date());
  }

  // ========= UI RENDER =========
  function renderCards(stopsWithArrivals, statusText) {
    statusLine.textContent = statusText || "";

    const now = Date.now();

    // Show exactly 2 cards, no scroll; if fewer -> show what we have
    const html = stopsWithArrivals.slice(0, 2).map((s, idx) => {
      const name = s.stopName || s.name || s.stop_name || `תחנה ${s.stopCode || s.stop_code || "?"}`;
      const dist = fmtDist(s.distanceMeters);

      const arrivals = (s.arrivals || []).slice(0, MAX_ARRIVALS_PER_STOP).map(a => {
        const mins = Math.max(0, Math.round((a.etaDate.getTime() - now) / 60000));
        const etaClock = a.etaDate.toLocaleTimeString("he-IL", { hour: "2-digit", minute: "2-digit" });
        const lineText = `קו ${a.routeNumber}${a.headsign ? ` • ${a.headsign}` : ""}`;

        return `
          <div class="arrival-row">
            <div class="line">${escapeHtml(lineText)}</div>
            <div class="eta">${etaClock} <span class="mins">(${mins} דק׳)</span></div>
          </div>
        `;
      }).join("");

      const empty = `<div class="arrival-row" style="opacity:.8;justify-content:center">אין זמני הגעה כרגע</div>`;

      return `
        <div class="card">
          <div class="card-top">
            <div class="stop-name">${idx+1}. ${escapeHtml(name)}</div>
            <div class="dist">${dist}</div>
          </div>
          <div class="arrivals">
            ${arrivals || empty}
          </div>
        </div>
      `;
    }).join("");

    cardsEl.innerHTML = html;
  }

  // ========= MAP =========
  function ensureMap() {
    if (map) return;

    map = L.map("map", { zoomControl: true }).setView(FALLBACK_CENTER, FALLBACK_ZOOM);

    // Clean/minimal basemap (same as your mapManager.js)
    L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: ""
    }).addTo(map);
  }

  function setUserMarker(lat, lon) {
    if (!map) return;

    if (userMarker) userMarker.remove();
    userMarker = L.circleMarker([lat, lon], {
      radius: 8,
      color: "#1976d2",
      fillColor: "#2196f3",
      fillOpacity: 0.7,
      weight: 2
    }).addTo(map).bindPopup("המיקום שלי");
  }

  function clearStopMarkers() {
    for (const m of stopMarkers) m.remove();
    stopMarkers = [];
  }

  function addStopMarker(idx, stop) {
    const lat = Number(stop.lat);
    const lon = Number(stop.lon);
    if (!isFinite(lat) || !isFinite(lon)) return;

    const name = stop.stopName || stop.name || stop.stop_name || `תחנה ${stop.stopCode || stop.stop_code || "?"}`;

    const icon = L.divIcon({
      className: "",
      html: `<div class="stopBadge">${idx}</div>`,
      iconSize: [24, 24],
      iconAnchor: [12, 12]
    });

    const m = L.marker([lat, lon], { icon }).addTo(map)
      .bindPopup(`${idx}. ${escapeHtml(name)}`);

    stopMarkers.push(m);
  }

  function fitToUserAndStops(user, stops) {
    if (!map) return;

    const pts = [];
    if (user && isFinite(user.lat) && isFinite(user.lon)) pts.push([user.lat, user.lon]);

    for (const s of stops) {
      const lat = Number(s.lat), lon = Number(s.lon);
      if (isFinite(lat) && isFinite(lon)) pts.push([lat, lon]);
    }

    if (pts.length >= 2) {
      map.fitBounds(L.latLngBounds(pts).pad(0.18));
    } else if (pts.length === 1) {
      map.setView(pts[0], USER_ZOOM, { animate: false });
    }
  }

  // ========= MAIN LOAD =========
  async function loadAllAndRender() {
    hideError();
    loadingCover.style.display = "grid";
    refreshBtn.disabled = true;
    refreshIcon.classList.add("spin");

    try {
      // 1) location
      const my = await getMyLocation();
      __wweb2Log(`loc: ${my.lat},${my.lon} fallback=${my.isFallback}`);

      // 2) nearby stops
      const nearby = await fetchNearbyStops(my.lat, my.lon);
      if (!nearby?.ok) throw new Error("nearbyStops ok=false: " + JSON.stringify(nearby));

      const stops = Array.isArray(nearby?.results) ? nearby.results : [];
      if (stops.length === 0) throw new Error("No nearby stops found");

      const stopA = stops[0];
      const stopB = stops[1] || null;

      const codeA = stopA.stopCode ?? stopA.stop_code ?? stopA.code ?? stopA.id;
      const codeB = stopB ? (stopB.stopCode ?? stopB.stop_code ?? stopB.code ?? stopB.id) : null;

      if (!codeA) throw new Error("Stop #1 missing stopCode");
      if (stopB && !codeB) throw new Error("Stop #2 missing stopCode");

      // 3) realtime for each stop (parallel)
      const [rtA, rtB] = await Promise.all([
        fetchRealtimeForStop(codeA),
        stopB ? fetchRealtimeForStop(codeB) : Promise.resolve(null)
      ]);

      const arrivalsA = extractArrivalsForStop(rtA, codeA, MAX_ARRIVALS_PER_STOP);
      const arrivalsB = stopB && rtB ? extractArrivalsForStop(rtB, codeB, MAX_ARRIVALS_PER_STOP) : [];

      updatedTimeEl.textContent = computeUpdatedTimeFromRealtime(rtA, rtB);

      const outStops = [
        Object.assign({}, stopA, { stopCode: String(codeA), arrivals: arrivalsA }),
      ];
      if (stopB) outStops.push(Object.assign({}, stopB, { stopCode: String(codeB), arrivals: arrivalsB }));

      const statusText = `מיקום: ${my.isFallback ? "Fallback" : "OK"} • תחנות: ${outStops.length}`;

      // ==== RENDER ====
      renderCards(outStops, statusText);

      ensureMap();
      setUserMarker(my.lat, my.lon);
      clearStopMarkers();
      outStops.slice(0, 2).forEach((s, i) => addStopMarker(i + 1, s));
      fitToUserAndStops(my, outStops.slice(0, 2));

      lastRendered = true;
      loadingCover.style.display = "none";
    } catch (e) {
      const msg = (e?.message || String(e));
      __wweb2Log("load error: " + (e?.stack || msg));

      statusLine.textContent = "שגיאה בטעינה";
      updatedTimeEl.textContent = "—";

      if (!lastRendered) {
        showError(msg);
        loadingCover.style.display = "grid";
      } else {
        showError(msg);
        loadingCover.style.display = "grid";
        setTimeout(() => { loadingCover.style.display = "none"; hideError(); }, 1800);
      }
    } finally {
      refreshBtn.disabled = false;
      refreshIcon.classList.remove("spin");
    }
  }

  window.addEventListener("DOMContentLoaded", async () => {
    await loadAllAndRender();
    refreshBtn.addEventListener("click", async () => {
      await loadAllAndRender();
    });
  });

})();
</script>
</body>
</html>
