<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="js-widget-title" content="Nearby Stops + Realtime" />
  <title>Nearby Stops + Realtime</title>

  <!-- Leaflet (local) -->
  <link rel="stylesheet" href="./leaflet.css">
  <script src="./leaflet.js"></script>

  <style>
    :root{
      --bg: #0f1012;
      --panel: rgba(20,20,22,.62);
      --panel2: rgba(255,255,255,.10);
      --border: rgba(255,255,255,.14);
      --text: #fff;
      --muted: rgba(255,255,255,.82);
      --ok: #9ef0a6;
      --err: #ffb3b3;
      --blue1: #1976d2;
      --blue2: #2196f3;
    }

    html, body { height: 100%; margin: 0; font-family: -apple-system, system-ui, Arial; background: var(--bg); }
    #app { height: 100%; width: 100%; display: grid; grid-template-rows: auto 1fr; }

    /* top bar */
    .topbar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px;
      color: var(--text);
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: 0 10px 25px rgba(0,0,0,.22);
      font-weight: 800;
      font-size: 13px;
      white-space: nowrap;
    }
    .time{
      font-variant-numeric: tabular-nums;
      opacity: .95;
    }
    .iconbtn{
      width: 38px; height: 38px;
      border: 0;
      border-radius: 12px;
      cursor: pointer;
      display: grid;
      place-items: center;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      color: #fff;
      -webkit-tap-highlight-color: transparent;
    }
    .iconbtn:active { transform: translateY(1px); }
    .iconbtn:disabled { opacity: .45; cursor: default; }
    .icon { width: 18px; height: 18px; display: block; }
    .spin { animation: spin 0.9s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* main split */
    .main{
      position: relative;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap: 10px;
      padding: 0 10px 10px 10px;
      min-height: 0;
    }
    @media (max-width: 820px){
      .main{ grid-template-columns: 1fr; grid-template-rows: 260px 1fr; }
    }

    /* left panel */
    .panel{
      min-height: 0;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,.22);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }
    .panel-head{
      padding: 10px 12px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .panel-title{
      font-weight: 900;
      font-size: 14px;
      color: var(--text);
      opacity: .98;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .panel-sub{
      font-size: 12px;
      color: var(--muted);
      opacity: .9;
      font-variant-numeric: tabular-nums;
    }
    .cards{
      padding: 10px;
      display:grid;
      gap: 10px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .card{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px;
    }
    .card-top{
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      color: var(--text);
    }
    .stop-name{
      font-weight: 900;
      font-size: 14px;
      line-height: 1.2;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 70%;
    }
    .dist{
      font-size: 12px;
      opacity: .85;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .arrivals{
      margin-top: 8px;
      display:grid;
      gap: 6px;
      color: var(--muted);
      font-size: 13px;
    }
    .arrival-row{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.08);
      font-variant-numeric: tabular-nums;
    }
    .line{
      font-weight: 900;
      color: #fff;
      opacity: .95;
      white-space: nowrap;
    }
    .eta{
      white-space: nowrap;
      color: #fff;
      opacity: .95;
      font-weight: 900;
    }
    .mins{
      opacity: .9;
      font-weight: 800;
    }

    /* map */
    .mapWrap{
      min-height: 0;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      overflow:hidden;
      box-shadow: 0 10px 25px rgba(0,0,0,.22);
      position: relative;
    }
    #map{ position:absolute; inset:0; }

    /* leaflet attribution tiny */
    .leaflet-control-attribution{
      font-size: 9px !important;
      opacity: .6;
      background: rgba(255,255,255,.65) !important;
      border-radius: 10px !important;
      padding: 2px 6px !important;
      margin: 0 8px 8px 0 !important;
    }

    /* markers */
    .stopBadge{
      width: 24px; height: 24px;
      border-radius: 999px;
      display:grid;
      place-items:center;
      font-weight: 900;
      font-size: 13px;
      color: #fff;
      background: rgba(255,255,255,.18);
      border: 2px solid rgba(255,255,255,.70);
      box-shadow: 0 8px 18px rgba(0,0,0,.25);
    }

    /* loading cover */
    .loading{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      z-index: 999999;
      background: linear-gradient(180deg, rgba(15,16,18,.96), rgba(15,16,18,.84));
      color: #fff;
      font-weight: 900;
      text-align:center;
      padding: 20px;
    }
    .loading small{
      display:block;
      margin-top: 8px;
      font-weight: 700;
      opacity: .75;
    }
    .errText{
      color: var(--err);
      font-weight: 900;
      margin-top: 10px;
      font-size: 13px;
      white-space: pre-wrap;
      text-align: right;
      max-width: 560px;
    }
  </style>
</head>

<body>
<div id="app">
  <div class="topbar">
    <div class="pill">
      <span>עודכן</span>
      <span class="time" id="updatedTime">—</span>
    </div>

    <button class="iconbtn" id="refreshBtn" title="רענן">
      <svg class="icon" id="refreshIcon" viewBox="0 0 24 24" fill="none">
        <path d="M20 12a8 8 0 1 1-2.34-5.66" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <path d="M20 4v6h-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
  </div>

  <div class="main" id="mainRoot">
    <div class="panel">
      <div class="panel-head">
        <div>
          <div class="panel-title">2 התחנות הקרובות</div>
          <div class="panel-sub" id="statusLine">טוען…</div>
        </div>
      </div>
      <div class="cards" id="cards"></div>
    </div>

    <div class="mapWrap">
      <div id="map"></div>
      <div class="loading" id="loadingCover">
        טוען נתונים…
        <small>מיקום → תחנות קרובות → זמני הגעה</small>
        <div class="errText" id="errBox" style="display:none;"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // Logger for WidgetWeb/JS-Widgets
  if (typeof __wweb2Log === 'undefined') window.__wweb2Log = (str) => console.log(str);

  // ========= CONFIG =========
  // NearbyStops WebApp (yours)
  const NEARBY_BASE = "https://script.google.com/macros/s/AKfycbwP9zZV4XDe8tsAdGAr3w3E8paS0-eQagw9b7gTnJBwYvqVbqZsbuFEN7FFPD7t-WeL/exec";

  // KavNav realtime
  const REALTIME_BASE = "https://kavnav.com/api/realtime";

  // Generic proxy (for local browser / CORS). Keeps it working reliably.
  // (Same style you used before: ?url=ENCODED_TARGET)
  const PROXY_BASE = "https://script.google.com/macros/s/AKfycbxKfWtTeeoOJCoR_WD4JQhvDGHcE3j82tVHVQXqElwL9NVO9ourZxSHTA20GoBJKfmiLw/exec";

  // refresh interval (optional) - you can keep it, but you asked "as few calls as possible".
  // We'll NOT auto-refresh by default. Only manual refresh.
  // const POLL_MS = 10_000;

  // Map defaults (fallback)
  const FALLBACK_CENTER = [31.78, 35.22];
  const FALLBACK_ZOOM = 16;

  // ========= DOM =========
  const el = (id) => document.getElementById(id);
  const updatedTimeEl = el("updatedTime");
  const refreshBtn = el("refreshBtn");
  const refreshIcon = el("refreshIcon");
  const statusLine = el("statusLine");
  const cardsEl = el("cards");
  const loadingCover = el("loadingCover");
  const errBox = el("errBox");

  // ========= STATE =========
  let map = null;
  let userMarker = null;
  let stopMarkers = []; // array of leaflet layers
  let lastRendered = false;

  // ========= HELPERS =========
  function proxyUrl(url) {
    return `${PROXY_BASE}?url=${encodeURIComponent(url)}`;
  }

  function fmtTimeOnly(isoOrDate) {
    const d = (isoOrDate instanceof Date) ? isoOrDate : new Date(isoOrDate);
    if (!isFinite(d.getTime())) return "—";
    return d.toLocaleTimeString("he-IL", { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  }

  function fmtDist(m) {
    if (!isFinite(m)) return "—";
    if (m < 1000) return `${Math.round(m)} מ׳`;
    return `${(m/1000).toFixed(1)} ק״מ`;
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function showError(msg) {
    errBox.style.display = "block";
    errBox.textContent = msg;
  }

  function hideError() {
    errBox.style.display = "none";
    errBox.textContent = "";
  }

  // ========= GEOLOCATION =========
  async function getMyLocation() {
    // IMPORTANT: do not hang forever; widget needs a fast resolve.
    return new Promise((resolve) => {
      if (!navigator.geolocation) {
        resolve({ lat: FALLBACK_CENTER[0], lon: FALLBACK_CENTER[1], isFallback: true });
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => resolve({
          lat: pos.coords.latitude,
          lon: pos.coords.longitude,
          isFallback: false
        }),
        () => resolve({ lat: FALLBACK_CENTER[0], lon: FALLBACK_CENTER[1], isFallback: true }),
        { enableHighAccuracy: false, timeout: 1500, maximumAge: 60_000 }
      );
    });
  }

  // ========= NETWORK =========
  async function fetchJson(url, useProxy = false) {
    const finalUrl = useProxy ? proxyUrl(url) : url;
    const res = await fetch(finalUrl, { cache: "no-store" });
    if (!res.ok) {
      const txt = await res.text().catch(() => "");
      throw new Error(`HTTP ${res.status} for ${finalUrl}\n${txt.slice(0,160)}`);
    }
    const text = await res.text();
    try { return JSON.parse(text); }
    catch { throw new Error("Invalid JSON response"); }
  }

  async function fetchNearbyStops(lat, lon) {
    // You said: add fn param to select function.
    const url = `${NEARBY_BASE}?fn=nearbyStops&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&limit=2`;
    return fetchJson(url, false); // same origin policy usually OK for script.google.com; keep direct
  }

  async function fetchRealtimeForStop(stopCode) {
    const url = `${REALTIME_BASE}?stopCode=${encodeURIComponent(stopCode)}`;
    // Use proxy to avoid CORS issues in local widget/browser
    return fetchJson(url, true);
  }

  // ========= REALTIME PARSING =========
  // From your sample JSON: vehicles[].trip.onwardCalls.calls[] includes stopCode + eta  [oai_citation:2‡kavnav.com-api-realtime.json](sediment://file_00000000c09871fdb1aacd04c619ca81)
  function extractArrivalsForStop(realtimeJson, stopCode, maxRows = 4) {
    const vehicles = Array.isArray(realtimeJson?.vehicles) ? realtimeJson.vehicles : [];
    const rows = [];

    for (const v of vehicles) {
      const calls = v?.trip?.onwardCalls?.calls;
      if (!Array.isArray(calls)) continue;

      const match = calls.find(c => String(c?.stopCode) === String(stopCode) && c?.eta);
      if (!match) continue;

      const etaIso = match.eta;
      const etaDate = new Date(etaIso);
      if (!isFinite(etaDate.getTime())) continue;

      const routeNumber = v?.trip?.gtfsInfo?.routeNumber ?? "";
      const headsign = v?.trip?.gtfsInfo?.headsign ?? "";

      rows.push({
        routeNumber: String(routeNumber || "—"),
        headsign: String(headsign || ""),
        etaIso,
        etaDate
      });
    }

    rows.sort((a, b) => a.etaDate - b.etaDate);
    return rows.slice(0, maxRows);
  }

  function computeUpdatedTimeFromRealtime(r1, r2) {
    const candidates = [
      r1?.lastSnapshot, r1?.lastVehicleReport,
      r2?.lastSnapshot, r2?.lastVehicleReport
    ].filter(Boolean);

    // pick the latest parsed date
    let best = null;
    for (const c of candidates) {
      const d = new Date(c);
      if (!isFinite(d.getTime())) continue;
      if (!best || d > best) best = d;
    }
    return best ? fmtTimeOnly(best) : fmtTimeOnly(new Date());
  }

  // ========= UI RENDER =========
  function renderCards(stopsWithArrivals, statusText) {
    statusLine.textContent = statusText || "";

    const now = Date.now();
    const html = stopsWithArrivals.map((s, idx) => {
      const name = s.stopName || s.name || s.stop_name || `תחנה ${s.stopCode || s.stop_code || "?"}`;
      const dist = fmtDist(s.distanceMeters);

      const arrivals = (s.arrivals || []).map(a => {
        const mins = Math.max(0, Math.round((a.etaDate.getTime() - now) / 60000));
        const etaClock = a.etaDate.toLocaleTimeString("he-IL", { hour: "2-digit", minute: "2-digit" });
        return `
          <div class="arrival-row">
            <div class="line">קו ${escapeHtml(a.routeNumber)}${a.headsign ? ` • ${escapeHtml(a.headsign)}` : ""}</div>
            <div class="eta">${etaClock} <span class="mins">(${mins} דק׳)</span></div>
          </div>
        `;
      }).join("");

      const empty = `<div class="arrival-row" style="opacity:.8;justify-content:center">אין זמני הגעה זמינים כרגע</div>`;

      return `
        <div class="card">
          <div class="card-top">
            <div class="stop-name">${idx+1}. ${escapeHtml(name)}</div>
            <div class="dist">${dist}</div>
          </div>
          <div class="arrivals">
            ${arrivals || empty}
          </div>
        </div>
      `;
    }).join("");

    cardsEl.innerHTML = html;
  }

  // ========= MAP =========
  function ensureMap() {
    if (map) return;

    map = L.map("map", { zoomControl: true }).setView(FALLBACK_CENTER, FALLBACK_ZOOM);

    // Clean/minimal basemap exactly like your mapManager.js  [oai_citation:3‡mapManager.js](sediment://file_000000001dcc71f8b7ddbbd5523fb33e)
    L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: ""
    }).addTo(map);
  }

  function setUserMarker(lat, lon) {
    if (!map) return;

    if (userMarker) userMarker.remove();
    userMarker = L.circleMarker([lat, lon], {
      radius: 8,
      color: "#1976d2",
      fillColor: "#2196f3",
      fillOpacity: 0.7,
      weight: 2
    }).addTo(map).bindPopup("המיקום שלי");
  }

  function clearStopMarkers() {
    for (const m of stopMarkers) m.remove();
    stopMarkers = [];
  }

  function addStopMarker(idx, stop) {
    const lat = Number(stop.lat);
    const lon = Number(stop.lon);
    if (!isFinite(lat) || !isFinite(lon)) return;

    const name = stop.stopName || stop.name || stop.stop_name || `תחנה ${stop.stopCode || stop.stop_code || "?"}`;

    const icon = L.divIcon({
      className: "",
      html: `<div class="stopBadge">${idx}</div>`,
      iconSize: [24, 24],
      iconAnchor: [12, 12]
    });

    const m = L.marker([lat, lon], { icon }).addTo(map)
      .bindPopup(`${idx}. ${escapeHtml(name)}`);

    stopMarkers.push(m);
  }

  function fitToUserAndStops(user, stops) {
    if (!map) return;

    const pts = [];
    if (user && isFinite(user.lat) && isFinite(user.lon)) pts.push([user.lat, user.lon]);

    for (const s of stops) {
      const lat = Number(s.lat), lon = Number(s.lon);
      if (isFinite(lat) && isFinite(lon)) pts.push([lat, lon]);
    }

    if (pts.length >= 2) {
      map.fitBounds(L.latLngBounds(pts).pad(0.18));
    } else if (pts.length === 1) {
      map.setView(pts[0], 17, { animate: false });
    }
  }

  // ========= MAIN LOAD (IMPORTANT: load all before painting) =========
  async function loadAllAndRender() {
    hideError();
    loadingCover.style.display = "grid";
    refreshBtn.disabled = true;
    refreshIcon.classList.add("spin");

    try {
      // 1) location
      const my = await getMyLocation();
      __wweb2Log(`loc: ${my.lat},${my.lon} fallback=${my.isFallback}`);

      // 2) nearby stops (2)
      const nearby = await fetchNearbyStops(my.lat, my.lon);
      if (!nearby?.ok) throw new Error("nearbyStops returned ok=false: " + JSON.stringify(nearby));

      const stops = Array.isArray(nearby?.results) ? nearby.results : [];
      if (stops.length === 0) throw new Error("No nearby stops found");

      // Normalize stopCode field name variants
      const stopA = stops[0];
      const stopB = stops[1] || null;

      const codeA = stopA.stopCode ?? stopA.stop_code ?? stopA.code ?? stopA.id;
      const codeB = stopB ? (stopB.stopCode ?? stopB.stop_code ?? stopB.code ?? stopB.id) : null;

      if (!codeA) throw new Error("Stop #1 missing stopCode");
      if (stopB && !codeB) throw new Error("Stop #2 missing stopCode");

      // 3) realtime for each stop (parallel)
      const [rtA, rtB] = await Promise.all([
        fetchRealtimeForStop(codeA),
        stopB ? fetchRealtimeForStop(codeB) : Promise.resolve(null)
      ]);

      const arrivalsA = extractArrivalsForStop(rtA, codeA, 4);
      const arrivalsB = stopB && rtB ? extractArrivalsForStop(rtB, codeB, 4) : [];

      // update time (time only)
      updatedTimeEl.textContent = computeUpdatedTimeFromRealtime(rtA, rtB);

      // prepare UI objects
      const outStops = [
        Object.assign({}, stopA, { stopCode: String(codeA), arrivals: arrivalsA }),
      ];
      if (stopB) outStops.push(Object.assign({}, stopB, { stopCode: String(codeB), arrivals: arrivalsB }));

      const statusText = `מיקום: ${my.isFallback ? "Fallback" : "OK"} • תחנות: ${outStops.length}`;

      // ==== RENDER (only now) ====
      // render left cards
      renderCards(outStops, statusText);

      // init map and markers
      ensureMap();
      setUserMarker(my.lat, my.lon);
      clearStopMarkers();
      outStops.forEach((s, i) => addStopMarker(i+1, s));

      // focus view
      fitToUserAndStops(my, outStops);

      lastRendered = true;
      loadingCover.style.display = "none";
    } catch (e) {
      const msg = (e?.message || String(e));
      __wweb2Log("load error: " + (e?.stack || msg));

      // If we already rendered once, keep old UI and just show error in status line.
      statusLine.textContent = "שגיאה בטעינה";
      updatedTimeEl.textContent = "—";

      if (!lastRendered) {
        showError(msg);
        loadingCover.style.display = "grid";
      } else {
        // show lightweight error overlay for a moment
        showError(msg);
        loadingCover.style.display = "grid";
        setTimeout(() => { loadingCover.style.display = "none"; hideError(); }, 1800);
      }
    } finally {
      refreshBtn.disabled = false;
      refreshIcon.classList.remove("spin");
    }
  }

  // ========= START =========
  window.addEventListener("DOMContentLoaded", async () => {
    // IMPORTANT: do full load before showing the page
    await loadAllAndRender();

    // Manual refresh only (min calls)
    refreshBtn.addEventListener("click", async () => {
      await loadAllAndRender();
    });

    // If you want auto-refresh, uncomment:
    // setInterval(loadAllAndRender, 10_000);
  });

})();
</script>
</body>
</html>
